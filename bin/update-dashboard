#!/usr/bin/env bash
set -euo pipefail

echo ">>> UPDATE DASHBOARD SCRIPT - LAST MODIFIED 2025-01-09 14:30 <<<"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# GitHub API base URL
GITHUB_API="https://api.github.com"
GITHUB_HEADERS=()
if [[ -n "${GITHUB_TOKEN:-}" ]]; then
  GITHUB_HEADERS=(-H "Authorization: token $GITHUB_TOKEN")
fi

# Function to make GitHub API calls
github_api() {
  local url="$1"
  local response
  response=$(curl -s "${GITHUB_HEADERS[@]}" "$url")

  # Check for rate limit
  if echo "$response" | jq -e '.message' | grep -q "rate limit" 2>/dev/null; then
    echo -e "${YELLOW}Warning: GitHub API rate limit reached${NC}" >&2
    echo '{"error": "rate_limit"}'
    return
  fi

  echo "$response"
}

# Function to discover packages dynamically
discover_packages() {
  ls packages/*.nix 2>/dev/null | sort | while read -r file; do
    basename "$file" .nix
  done
}

# Function to extract metadata from nix file
get_package_metadata() {
  local package="$1"
  local file="packages/${package}.nix"
  
  if [[ ! -f "$file" ]]; then
    echo -e "${YELLOW}Warning: Package file $file not found${NC}" >&2
    echo '{"upstream": null, "nixpkgsPath": null}'
    return
  fi

  # Try to extract nixautopkgs metadata using nix eval
  local metadata
  if command -v nix >/dev/null 2>&1; then
    # Try using the flake output directly
    metadata=$(nix eval --impure --json ".#$package.meta.nixautopkgs" 2>/dev/null || echo '{"upstream": null, "nixpkgsPath": null}')
  else
    echo -e "${YELLOW}Warning: nix command not available, cannot extract metadata${NC}" >&2
    echo '{"upstream": null, "nixpkgsPath": null}'
    return
  fi

  echo "$metadata"
}

# Function to get latest release from GitHub
get_latest_release() {
  local upstream="$1"
  local owner repo
  
  if [[ -z "$upstream" || "$upstream" == "null" ]]; then
    echo "unknown"
    return
  fi

  IFS='/' read -r owner repo <<< "$upstream"
  local release_data
  release_data=$(github_api "$GITHUB_API/repos/$owner/$repo/releases/latest")

  # Check for errors
  if [[ $(echo "$release_data" | jq -r '.error // empty') == "rate_limit" ]]; then
    echo "unknown"
  elif [[ $(echo "$release_data" | jq -r '.message // empty') == "Not Found" ]]; then
    echo "unknown"
  else
    echo "$release_data" | jq -r '.tag_name // "unknown"'
  fi
}

# Function to extract version from nix file
get_nix_version() {
  local file="$1"
  if [[ -f "$file" ]]; then
    grep -E '^\s*version\s*=\s*"[^"]+";' "$file" | sed -E 's/.*"([^"]+)".*/\1/' | head -1
  else
    echo "unknown"
  fi
}

# Function to get nixpkgs version
get_nixpkgs_version() {
  local nixpkgs_path="$1"
  
  if [[ -z "$nixpkgs_path" || "$nixpkgs_path" == "null" ]]; then
    echo "â€”"
    return
  fi

  # Try to get version from nixpkgs-unstable
  if command -v nix >/dev/null 2>&1; then
    # Extract package name from path (e.g., pkgs/by-name/gc/gcs/package.nix -> gcs)
    local package_name
    package_name=$(echo "$nixpkgs_path" | sed -E 's|.*/([^/]+)/package\.nix|\1|')
    
    local version
    version=$(nix eval --impure --expr "(import <nixpkgs> {}).${package_name}.version or \"unknown\"" 2>/dev/null | tr -d '"') || echo "unknown"
    echo "${version:-unknown}"
  else
    echo "unknown"
  fi
}

# Function to find PR that updated package version
find_version_pr() {
  local package="$1"
  local version="$2"

  # Search for PRs that mention the package and version
  local search_query="repo:ndrwstn/nixautopkgs is:pr is:merged \"$package\" \"$version\""
  local pr_data
  pr_data=$(github_api "$GITHUB_API/search/issues?q=$(echo "$search_query" | jq -sRr @uri)&sort=created&order=desc&per_page=1")

  if [[ $(echo "$pr_data" | jq -r '.total_count // 0') -gt 0 ]]; then
    echo "$pr_data" | jq -r '.items[0].number // ""'
  else
    # Fallback: look for recent PRs that modified the package file
    local recent_prs
    recent_prs=$(github_api "$GITHUB_API/repos/ndrwstn/nixautopkgs/pulls?state=closed&sort=updated&direction=desc&per_page=20")

    for pr_number in $(echo "$recent_prs" | jq -r '.[].number'); do
      local files_changed
      files_changed=$(github_api "$GITHUB_API/repos/ndrwstn/nixautopkgs/pulls/$pr_number/files")

      if echo "$files_changed" | jq -r '.[].filename' | grep -q "packages/${package}.nix"; then
        echo "$pr_number"
        return
      fi
    done

    echo ""
  fi
}

# Function to check platform support from nix meta
check_platform_support() {
  local package="$1"
  local file="packages/${package}.nix"

  if [[ ! -f "$file" ]]; then
    echo "x86_64-linux:?"
    echo "aarch64-linux:?"
    echo "x86_64-darwin:?"
    echo "aarch64-darwin:?"
    return
  fi

  # Try to extract broken conditions using nix eval
  if command -v nix >/dev/null 2>&1; then
    # Check if meta.broken exists and what it evaluates to for different platforms
    local platforms=("x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin")
    for platform in "${platforms[@]}"; do
      local is_broken
      # Use flake output with system override
      is_broken=$(nix eval --impure --json --expr "
        let
          flake = builtins.getFlake (toString ./.);
          pkg = flake.packages.\"$platform\".\"$package\";
        in
          pkg.meta.broken or false
      " 2>/dev/null || echo "null")
      
      if [[ "$is_broken" == "true" ]]; then
        echo "${platform}:â€”"
      elif [[ "$is_broken" == "false" ]]; then
        echo "${platform}:âœ“"
      else
        echo "${platform}:?"
      fi
    done
  else
    # Fallback: simple grep-based detection
    local is_broken_linux_aarch64="false"
    if grep -q "broken.*isLinux.*isAarch64" "$file" 2>/dev/null; then
      is_broken_linux_aarch64="true"
    fi

    echo "x86_64-linux:âœ“"
    if [[ "$is_broken_linux_aarch64" == "true" ]]; then
      echo "aarch64-linux:â€”"
    else
      echo "aarch64-linux:âœ“"
    fi
    echo "x86_64-darwin:âœ“"
    echo "aarch64-darwin:âœ“"
  fi
}

# Function to get build status from GitHub Actions
get_build_status() {
  local package="$1"
  local pr_number="$2"

  if [[ -z "$pr_number" ]]; then
    check_platform_support "$package"
    return
  fi

  # Get PR data to find the head SHA
  local pr_data
  pr_data=$(github_api "$GITHUB_API/repos/ndrwstn/nixautopkgs/pulls/$pr_number")
  local head_sha
  head_sha=$(echo "$pr_data" | jq -r '.head.sha // ""')

  if [[ -z "$head_sha" ]]; then
    check_platform_support "$package"
    return
  fi

  # Get check runs for the commit
  local check_runs
  check_runs=$(github_api "$GITHUB_API/repos/ndrwstn/nixautopkgs/commits/$head_sha/check-runs")

  # Parse build status for each platform
  local platforms=("x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin")
  for platform in "${platforms[@]}"; do
    local status="?"
    local check_name="Build ${platform}"

    local conclusion
    conclusion=$(echo "$check_runs" | jq -r ".check_runs[] | select(.name == \"$check_name\") | .conclusion // \"unknown\"")

    case "$conclusion" in
    success)
      status="âœ“"
      ;;
    failure | cancelled | timed_out)
      status="âœ—"
      ;;
    skipped)
      status="â€”"
      ;;
    *)
      # Fall back to platform support check
      local platform_support
      platform_support=$(check_platform_support "$package" | grep "^${platform}:" | cut -d: -f2)
      status="${platform_support:-?}"
      ;;
    esac

    echo "${platform}:${status}"
  done
}

# Function to normalize version (strip 'v' prefix if present)
normalize_version() {
  local version="$1"
  echo "$version" | sed 's/^v//'
}

# Main function to generate dashboard
generate_dashboard() {
  local timestamp
  timestamp=$(date -u '+%Y-%m-%d %H:%M UTC')

  echo -e "${GREEN}Generating package dashboard...${NC}" >&2

  # Start building the dashboard content
  local dashboard_content=""
  dashboard_content+="<!-- DASHBOARD:START -->"$'\n'
  dashboard_content+="## ðŸ“¦ Package Status"$'\n'
  dashboard_content+="*Last updated: ${timestamp} â€¢ [â†» Update](https://github.com/ndrwstn/nixautopkgs/actions/workflows/update-dashboard.yml)*"$'\n\n'

  # Version table header
  dashboard_content+="| Package | Latest Release | Our Version | Nixpkgs Unstable |"$'\n'
  dashboard_content+="|---------|---------------|-------------|------------------|"$'\n'

  # Discover packages dynamically
  local packages
  mapfile -t packages < <(discover_packages)
  
  if [[ ${#packages[@]} -eq 0 ]]; then
    echo -e "${RED}Error: No packages found in packages/ directory${NC}" >&2
    exit 1
  fi

  # Store build status for platform table
  declare -A build_status

  # Process each package
  for package in "${packages[@]}"; do
    echo -e "${YELLOW}Processing ${package}...${NC}" >&2

    # Get package metadata
    local metadata
    metadata=$(get_package_metadata "$package")
    local upstream
    upstream=$(echo "$metadata" | jq -r '.upstream // null')
    local nixpkgs_path
    nixpkgs_path=$(echo "$metadata" | jq -r '.nixpkgsPath // null')

    # Validate upstream
    if [[ -z "$upstream" || "$upstream" == "null" ]]; then
      echo -e "${YELLOW}Warning: Package $package has no upstream metadata, skipping${NC}" >&2
      continue
    fi

    # Get versions
    local our_version
    our_version=$(get_nix_version "packages/${package}.nix")

    local latest_version
    latest_version=$(get_latest_release "$upstream")

    local nixpkgs_version
    nixpkgs_version=$(get_nixpkgs_version "$nixpkgs_path")

    # Find PR for our version
    local pr_number
    pr_number=$(find_version_pr "$package" "$our_version")

    # Extract owner/repo from upstream
    local owner repo
    IFS='/' read -r owner repo <<< "$upstream"

    # Format versions with links
    local latest_link
    if [[ "$latest_version" != "unknown" ]]; then
      latest_link="[${latest_version}](https://github.com/${owner}/${repo}/releases/tag/${latest_version})"
    else
      latest_link="unknown"
    fi

    local our_link
    if [[ -n "$pr_number" ]]; then
      # Handle version normalization for display (add 'v' prefix if not present)
      local display_version="$our_version"
      if [[ ! "$our_version" =~ ^v ]]; then
        display_version="v${our_version}"
      fi
      our_link="[${display_version}](https://github.com/ndrwstn/nixautopkgs/pull/${pr_number})"
    else
      local display_version="$our_version"
      if [[ ! "$our_version" =~ ^v ]]; then
        display_version="v${our_version}"
      fi
      our_link="$display_version"
    fi

    local nixpkgs_link
    if [[ "$nixpkgs_version" != "unknown" && "$nixpkgs_version" != "â€”" ]]; then
      if [[ -n "$nixpkgs_path" && "$nixpkgs_path" != "null" ]]; then
        local display_nixpkgs_version="$nixpkgs_version"
        if [[ ! "$nixpkgs_version" =~ ^v ]]; then
          display_nixpkgs_version="v${nixpkgs_version}"
        fi
        nixpkgs_link="[${display_nixpkgs_version}](https://github.com/NixOS/nixpkgs/blob/master/${nixpkgs_path})"
      else
        nixpkgs_link="v${nixpkgs_version}"
      fi
    else
      nixpkgs_link="$nixpkgs_version"
    fi

    # Add row to version table
    dashboard_content+="| [${package}](./packages/${package}.nix) | ${latest_link} | ${our_link} | ${nixpkgs_link} |"$'\n'

    # Store build status for platform table
    while IFS=: read -r platform status; do
      build_status["${package}_${platform}"]="$status"
    done < <(get_build_status "$package" "$pr_number")
  done

  # Platform support table
  dashboard_content+=$'\n'"### Platform Support"$'\n\n'
  dashboard_content+="| Package | x86_64-linux | aarch64-linux | x86_64-darwin | aarch64-darwin |"$'\n'
  dashboard_content+="|---------|-------------|---------------|---------------|----------------|"$'\n'

  for package in "${packages[@]}"; do
    # Skip packages without upstream metadata
    local metadata
    metadata=$(get_package_metadata "$package")
    local upstream
    upstream=$(echo "$metadata" | jq -r '.upstream // null')
    
    if [[ -z "$upstream" || "$upstream" == "null" ]]; then
      continue
    fi

    local row="| ${package}"
    for platform in x86_64-linux aarch64-linux x86_64-darwin aarch64-darwin; do
      local status="${build_status["${package}_${platform}"]:-?}"
      row+=" | ${status}"
    done
    dashboard_content+="${row} |"$'\n'
  done

  dashboard_content+=$'\n'"*Legend: âœ“ Built successfully â€¢ âœ— Build failed â€¢ â€” Not supported â€¢ ? Unknown*"$'\n'
  dashboard_content+="<!-- DASHBOARD:END -->"$'\n\n\n'

  echo "$dashboard_content"
}

# Update README.md with new dashboard
update_readme() {
  local dashboard_content="$1"
  local readme_file="README.md"

  if [[ ! -f "$readme_file" ]]; then
    echo -e "${RED}Error: README.md not found${NC}"
    exit 1
  fi

  # Create backup
  cp "$readme_file" "${readme_file}.bak"

  # Save dashboard content to temp file
  local temp_dashboard=$(mktemp)
  printf "%s" "$dashboard_content" >"$temp_dashboard"

  # Create new README content
  local temp_readme=$(mktemp)

  # Check if dashboard markers exist
  if grep -q "<!-- DASHBOARD:START -->" "$readme_file"; then
    # Replace existing dashboard
    echo -e "${GREEN}Updating existing dashboard...${NC}"

    # Process file line by line
    local in_dashboard=false
    local dashboard_written=false
    while IFS= read -r line || [[ -n "$line" ]]; do
      if [[ "$line" == *"<!-- DASHBOARD:START -->"* ]]; then
        if [[ "$dashboard_written" == false ]]; then
          cat "$temp_dashboard"
          dashboard_written=true
        fi
        in_dashboard=true
      elif [[ "$line" == *"<!-- DASHBOARD:END -->"* ]]; then
        in_dashboard=false
      elif [[ "$in_dashboard" == false ]]; then
        echo "$line"
      fi
    done <"$readme_file" >"$temp_readme"
  else
    # Add dashboard after title and description
    echo -e "${GREEN}Adding new dashboard...${NC}"

    # Insert after line 3
    local line_num=0
    while IFS= read -r line || [[ -n "$line" ]]; do
      line_num=$((line_num + 1))
      echo "$line"
      if [[ $line_num -eq 3 ]]; then
        echo ""
        cat "$temp_dashboard"
      fi
    done <"$readme_file" >"$temp_readme"
  fi

  # Replace original file with updated content
  mv "$temp_readme" "$readme_file"

  # Clean up
  rm "$temp_dashboard"
  if [[ -f "${readme_file}.bak" ]]; then
    rm "${readme_file}.bak"
  fi

  echo -e "${GREEN}Dashboard updated successfully!${NC}"
}

# Main execution
main() {
  echo -e "${GREEN}Starting dashboard update...${NC}"

  # Generate dashboard content
  local dashboard_content
  dashboard_content=$(generate_dashboard)

  # Update README
  update_readme "$dashboard_content"

  echo -e "${GREEN}Dashboard update complete!${NC}"
}

# Run main function
main "$@"